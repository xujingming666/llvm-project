#include "DummyInstrInfo.h"
#include "DummySubtarget.h"
#include "DummyTargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "dummy-ISelDAGToDAG"

namespace {
class DummyDAGToDAGISel : public SelectionDAGISel {
  const DummySubtarget &Subtarget;

public:
  explicit DummyDAGToDAGISel(DummyTargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel), Subtarget(*TM.getSubtargetImpl()) {}

  void SelectMoveImmediate(SDNode *N);
  void Select(SDNode *N) override;
  virtual StringRef getPassName() const override {
    return "Dummy DAG->DAG Pattern Instruction Selection";
  }
  bool SelectAddrImm12(SDValue N, SDValue &Base,
                                      SDValue &Offset);
  void SelectConditionalBranch(SDNode *N);

private:
// Include the pieces autogenerated from the target description.
#include "DummyGenDAGISel.inc"
};
} // end anonymous namespace

void DummyDAGToDAGISel::SelectMoveImmediate(SDNode *N) {
  // Make sure the immediate size is supported.
  ConstantSDNode *ConstVal = cast<ConstantSDNode>(N);
  uint64_t ImmVal = ConstVal->getZExtValue();
  uint64_t SupportedMask = 0xfffffffff;
  if ((ImmVal & SupportedMask) != ImmVal) {
    SelectCode(N);
    return;
  }

  // Replace the constant assignment with
  // the "MOVi32" operation
  SDLoc DL(N);
  SDValue Const = CurDAG->getTargetConstant(ImmVal, DL, MVT::i32);
  MachineSDNode *Move =
      CurDAG->getMachineNode(Dummy::MOVE_I32, DL, MVT::i32, Const);

  ReplaceNode(N, Move);
}

void DummyDAGToDAGISel::Select(SDNode *N) {


  switch (N->getOpcode()) {
  case ISD::Constant: 
    SelectMoveImmediate(N);
    break;
  case ISD::BR_CC: {
    SelectConditionalBranch(N);
    break;
  }
  default:
    SelectCode(N);
  }
  N->print(llvm::errs());
  llvm::errs() << "\n DummyDAGToDAGISel::Select xujing" << N->getOpcode() << "\n";
  return;
}

bool DummyDAGToDAGISel::SelectAddrImm12(SDValue Addr, SDValue &Base,
                                      SDValue &Offset) {
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    EVT ValTy = Addr.getValueType();
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
    return true;
  }

  return false;
}

void DummyDAGToDAGISel::SelectConditionalBranch(SDNode *N) {
  SDValue Chain = N->getOperand(0);
  SDValue Cond = N->getOperand(1);
  SDValue LHS = N->getOperand(2);
  SDValue RHS = N->getOperand(3);
  SDValue Target = N->getOperand(4);
  bool Swap = false;

  // Generate a predicated branch instruction.
  // Change non-native cond code with swapped operands, e.g.
  // br_cc SETGT %1, %2, %target => BLT %2, %1, %target
  CondCodeSDNode *CC = cast<CondCodeSDNode>(Cond.getNode());
  ISD::CondCode CCOp = CC->get();
  unsigned RetOp;
  switch (CCOp) {
  case ISD::SETGT:
    RetOp = Dummy::L_BLTS;
    Swap = true;
    break;
  case ISD::SETUGT:
  case ISD::SETOGT:
    RetOp =  Dummy::L_BLTU;
    Swap = true;
    break;
  case ISD::SETLE:
    RetOp = Dummy::L_BGES;
    Swap = true;
    break;
  case ISD::SETULE:
  case ISD::SETOLE:
    RetOp =  Dummy::L_BGEU;
    Swap = true;
    break;
  case ISD::SETEQ:
  case ISD::SETUEQ:
  case ISD::SETOEQ:
    RetOp = Dummy::L_BEQ;
    break;
  case ISD::SETNE:
  case ISD::SETONE:
  case ISD::SETUNE:
    RetOp =  Dummy::L_BNE;
    break;
  case ISD::SETGE:
    RetOp = Dummy::L_BGES;
    break;
  case ISD::SETOGE:
  case ISD::SETUGE:
    RetOp = Dummy::L_BGEU;
    break;
  case ISD::SETLT:
    RetOp =  Dummy::L_BLTS;
    break;
  case ISD::SETOLT:
  case ISD::SETULT:
    RetOp =  Dummy::L_BLTU;
    break;
  default:
    llvm_unreachable("unsupported condition code");
  }

  ConstantSDNode *CN;
  if ((CN = dyn_cast<ConstantSDNode>(LHS)) && CN->getZExtValue() == 0) {
    LHS = CurDAG->getRegister(Dummy::R0, CN->getValueType(0));
  }
  if ((CN = dyn_cast<ConstantSDNode>(RHS)) && CN->getZExtValue() == 0) {
    RHS = CurDAG->getRegister(Dummy::R0, CN->getValueType(0));
  }

  SDValue BranchOps[] = {Swap ? RHS : LHS, Swap ? LHS : RHS, Target, Chain};
  SDNode *NewN = CurDAG->getMachineNode(RetOp, N, MVT::Other, BranchOps);
  ReplaceNode(N, NewN);

  return;
}


FunctionPass *createDummyIselPass(DummyTargetMachine &TM,
                                  CodeGenOpt::Level OptLevel) {
  return new DummyDAGToDAGISel(TM, OptLevel);
}
